#pragma kernel EmitWithSpherePartial
#pragma kernel EmitWithSphere
#pragma kernel EmitWithSphereAndEffector
#pragma kernel EmitWithTexture
#pragma kernel EmitWithTextureAndEffector
#pragma kernel Advect
#pragma kernel AdvectBackward
#pragma kernel AdvectMacCormack
#pragma kernel SimulateAIOClamped
#pragma kernel SimulateAIOUnclamped
#pragma kernel Divergence
#pragma kernel JaccobiClamped
#pragma kernel JaccobiUnclamped
#pragma kernel ProjectClamped
#pragma kernel ProjectUnclamped
#pragma kernel Vorticity
#pragma kernel Confinement
#pragma kernel Clear

#define INFINITY 10e10
#define kMaxAffectors 3

#define UP_CLAMPED			min(_DimensionsMinusOne,	index + uint3(0, 1, 0) )
#define DOWN_CLAMPED		max(0..xxx,					index - uint3(0, 1, 0) )
#define RIGHT_CLAMPED		min(_DimensionsMinusOne,	index + uint3(1, 0, 0) )
#define LEFT_CLAMPED		max(0..xxx,					index - uint3(1, 0, 0) )
#define FORWARD_CLAMPED		min(_DimensionsMinusOne,	index + uint3(0, 0, 1) )
#define BACK_CLAMPED		max(0..xxx,					index - uint3(0, 0, 1) )

#define UP_4_CLAMPED		min(_QuarterDimensionsMinusOne,	index + uint3(0, 1, 0) )
#define DOWN_4_CLAMPED		index - uint3(0, 1, 0)
#define RIGHT_4_CLAMPED		min(_QuarterDimensionsMinusOne,	index + uint3(1, 0, 0) )
#define LEFT_4_CLAMPED		index - uint3(1, 0, 0)
#define FORWARD_4_CLAMPED	min(_QuarterDimensionsMinusOne,	index + uint3(0, 0, 1) )
#define BACK_4_CLAMPED		index - uint3(0, 0, 1)

#define UP_UNCLAMPED		uint3(index.x, index.y + 1, index.z)
#define DOWN_UNCLAMPED		uint3(index.x, index.y - 1, index.z)
#define RIGHT_UNCLAMPED		uint3(index.x + 1, index.y, index.z)
#define LEFT_UNCLAMPED		uint3(index.x - 1, index.y, index.z)
#define FORWARD_UNCLAMPED	uint3(index.x, index.y, index.z + 1)
#define BACK_UNCLAMPED		uint3(index.x, index.y, index.z - 1)

#define UP_4_UNCLAMPED			UP
#define DOWN_4_UNCLAMPED		DOWN
#define RIGHT_4_UNCLAMPED		RIGHT
#define LEFT_4_UNCLAMPED		LEFT
#define FORWARD_4_UNCLAMPED		FORWARD
#define BACK_4_UNCLAMPED		BACK

#define UP		(ShouldClamp ? UP_CLAMPED		: UP_UNCLAMPED)
#define DOWN	(ShouldClamp ? DOWN_CLAMPED		: DOWN_UNCLAMPED)
#define RIGHT	(ShouldClamp ? RIGHT_CLAMPED	: RIGHT_UNCLAMPED)
#define LEFT	(ShouldClamp ? LEFT_CLAMPED		: LEFT_UNCLAMPED)
#define FORWARD (ShouldClamp ? FORWARD_CLAMPED	: FORWARD_UNCLAMPED)
#define BACK	(ShouldClamp ? BACK_CLAMPED		: BACK_UNCLAMPED)

#define UP_4		(ShouldClamp ? UP_4_CLAMPED			: UP_4_UNCLAMPED)
#define DOWN_4		(ShouldClamp ? DOWN_4_CLAMPED		: DOWN_4_UNCLAMPED)
#define RIGHT_4		(ShouldClamp ? RIGHT_4_CLAMPED		: RIGHT_4_UNCLAMPED)
#define LEFT_4		(ShouldClamp ? LEFT_4_CLAMPED		: LEFT_4_UNCLAMPED)
#define FORWARD_4	(ShouldClamp ? FORWARD_4_CLAMPED	: FORWARD_4_UNCLAMPED)
#define BACK_4		(ShouldClamp ? BACK_4_CLAMPED		: BACK_4_UNCLAMPED)

#define kCollisionShift		( 0 )
#define kTempEmitterShift	( 1 )
#define kReceiverShift		( 2 )
#define kTurbulenceShift	( 3 )
#define kCollisionMask		( 1 << kCollisionShift )
#define kTempEmitterMask	( 1 << kTempEmitterShift )
#define kReceiverMask		( 1 << kReceiverShift )
#define kTurbulenceMask		( 1 << kTurbulenceShift )

struct Affector
{
	float4 position_radius;

	float temperature;
	float power;

	uint mask;// Bottom 8 bits are reseved for effector type. Next 2 bits represent channel.
    uint pk_direction;	// XYZ direction packed into 32bit uint.
};

const static uint3 texCoordLimits[8] =
{
	uint3(0, 0, 0),
	uint3(1, 0, 0),
	uint3(0, 1, 0),
	uint3(1, 1, 0),
	uint3(0, 0, 1),
	uint3(1, 0, 1),
	uint3(0, 1, 1),
	uint3(1, 1, 1)
};

AppendStructuredBuffer<uint3> _PartialFluidKeysAB	: register( u6 );
RWStructuredBuffer<Affector> _AffectorsRW	: register( u5 );
RWTexture3D<float3>	_VelocityTexRW			: register( u4 );
RWTexture3D<float4>	_VorticityTexRW			: register( u3 );
RWTexture3D<float4>	_DivergenceTexRW		: register( u2 ); 
RWTexture3D<float4>	_ReactionTexRW			: register( u1 ); 
RWTexture3D<float4>	_PressureTexRW			: register( u0 );

Buffer<uint3> _PartialFluidKeys;
StructuredBuffer<Affector> _Affectors;
Texture3D<float4>	_VorticityTex;
Texture3D<float3>	_VelocityTex;
Texture3D<float3>	_VelocityTexA;
Texture3D<float4>	_DivergenceTex;
Texture3D<float4>	_PressureTex;
Texture3D<float4>	_ReactionTex; 

Texture2D<float4>	_EmitterTex; 
SamplerState sampler_EmitterTex;

SamplerState sampler_VelocityTex;
SamplerState sampler_VelocityTexA;
SamplerState sampler_DivergenceTex;
SamplerState sampler_PressureTex;
SamplerState sampler_ReactionTex;

cbuffer Static
{
	uint3 _Dimensions;
	uint3 _DimensionsMinusOne;
	uint3 _QuarterDimensionsMinusOne;
	float4 _RecipDimensions;
	float4 _HalfVoxel;
	float4 _DimensionAspectRatio;
	float _RecipMaxDimension;
}

cbuffer Dynamic
{
	float3 _SourcePosition;
	float3 _Force;
	float3 _Translation;
	float _ForceMag;
	float _ReactionSpeed;
	float _InvRadius;
	float _ConfinementScale;
	float _Viscosity;
	float3 _Gravity;
	float _TimeScale;
	uint3 _Partial_BottomLeftIdx;
}

float4 UnpackUintIntoFloat4(uint uValue)
{
    return float4( ( (uValue & 0xFF000000)>>24 ) / 255.0, ( (uValue & 0x00FF0000)>>16 ) / 255.0, ( (uValue & 0x0000FF00)>>8 ) / 255.0, ( (uValue & 0x000000FF) ) / 255.0);
}

inline bool IsNotWithinDimensions( uint3 i )
{
	return ( i.x >= _Dimensions.x || i.y >= _Dimensions.y || i.z >= _Dimensions.z );
}

inline bool IsBoundry( uint3 i )
{
	return ( i.x >= _DimensionsMinusOne.x || i.y >= _DimensionsMinusOne.y || i.z >= _DimensionsMinusOne.z );
}

inline uint GetEffectorChannel( const uint mask )
{
	return ( mask & 0x300 ) >> 8; 
}

inline uint IsInside(const uint3 idx, const Affector a, const uint mask, const uint shift)
{
	const float4 sphere = a.position_radius;
	const float3 relativePos = idx - sphere.xyz;
	const float radius = rcp(sphere.w) * rcp(sphere.w) * ((a.mask & mask) >> shift);

	return uint(step(dot( relativePos, relativePos ), radius) + 0.5f);
}

inline bool ApplyEffectorCollisions(const uint3 idx, const uint mask, const uint shift)
{
	uint inside = 0;

	Affector a;
#	if kMaxAffectors
	[unroll(kMaxAffectors)]
	for(uint i=(kMaxAffectors-1) ; i>=0 ; --i)
	{	
		a = _Affectors[i];
		const float4 sphere = a.position_radius;
		const float3 relativePos = idx - sphere.xyz;
		const float radius = rcp(sphere.w) * rcp(sphere.w) * ((a.mask & mask) >> shift);
		inside |= uint(step(dot( relativePos, relativePos ), radius) + 0.5f);
	}
#	endif

	return inside;
}

float3 ApplyEffector(const uint3 idx, float temp, out float4 rCoord)
{
	float3 force = 0..xxx;

	float r[4] = { 0, 0, 0, 0 };

#	if kMaxAffectors
	for( uint i=0 ; i<kMaxAffectors ; ++i )
	{	
		Affector a = _AffectorsRW[i];
		const float4 sphere = a.position_radius;
		const float3 relativePos = idx - sphere.xyz;
		const float relativePosSq = dot( relativePos, relativePos ); 
		const float invRadius = sphere.w;

		const float power = exp(-relativePosSq * invRadius);
		const float enabled = ((a.mask & kTempEmitterMask) >> kTempEmitterShift);
		const float magnitude = power * enabled * a.power;

		const uint channel = GetEffectorChannel( a.mask );
		r[channel] += magnitude;

		float3 direction = (UnpackUintIntoFloat4(a.pk_direction).xyz * 2 - 1);
		force += (magnitude + IsInside(idx, a, kTurbulenceMask, kTurbulenceShift) * a.power * 0.016f) * direction;

		const float radius = rcp(sphere.w) * rcp(sphere.w) * ((a.mask & kReceiverMask) >> kReceiverShift);
		_AffectorsRW[i].temperature += step(relativePosSq, radius) * (temp+magnitude);
	}
#	endif

	rCoord = float4(r[0], r[1], r[2], r[3]);

	return force;
}
 
[numthreads(8, 8, 8)]
void EmitWithSphere(uint3 i : SV_DispatchThreadID)
{ 
	[branch]
	if( IsNotWithinDimensions( i ) ) return;

	const float3 rPosition =  i - _SourcePosition;
  
	const float radiusSq = dot(rPosition, rPosition);
  
	const float injection = exp(-radiusSq * _InvRadius);

	const float3 emitterForce = _Force * injection;

	_VelocityTexRW[i] = _VelocityTex[i] + emitterForce;  
	_ReactionTexRW[i] = _ReactionTex[i] + float4( injection * _ForceMag, 0..xxx);
}

[numthreads(8, 8, 8)]
void EmitWithSpherePartial(uint3 i : SV_DispatchThreadID)
{ 
	i += _Partial_BottomLeftIdx;

	[branch]
	if( IsNotWithinDimensions( i ) ) return;

	const float3 rPosition =  i - _SourcePosition;
  
	const float radiusSq = dot(rPosition, rPosition);
  
	const float injection = exp(-radiusSq * _InvRadius);

	const float3 emitterForce = _Force * injection;

	_VelocityTexRW[i] = _VelocityTex[i] + emitterForce;  
	_ReactionTexRW[i] = _ReactionTex[i] + float4( injection * _ForceMag, 0..xxx);
}

[numthreads(8, 8, 8)]
void EmitWithSphereAndEffector(uint3 i : SV_DispatchThreadID)
{ 
	[branch]
	if( IsNotWithinDimensions( i ) ) return;

	const float3 rPosition =  i - _SourcePosition;
  
	const float radiusSq = dot(rPosition, rPosition);
	const float injection = exp(-radiusSq * _InvRadius);

	float4 currentReactionCoord = _ReactionTex[i];
	currentReactionCoord.x = mad(_ForceMag, injection, currentReactionCoord.x);

	float4 affectorReaction = 0..xxxx;

	const float3 emitterForce = _Force * injection;
	const float3 affectorForce = ApplyEffector( i, currentReactionCoord.x, affectorReaction );
	const float3 resultantForce = emitterForce + affectorForce;

	_VelocityTexRW[i] = _VelocityTex[i] + resultantForce;  
	_ReactionTexRW[i] = currentReactionCoord + affectorReaction;
}
 
[numthreads(8, 8, 8)]
void EmitWithTexture(uint3 i : SV_DispatchThreadID)
{ 
	[branch]
	if( IsNotWithinDimensions( i ) ) return;

	// And lets assume always emit from the bottom.
	const float3 rPosition =  float3(0, i.y, 0);
	const float2 uvw = mad(i.xz, _RecipDimensions.xz, _HalfVoxel.xz);

	const float texStrength = _EmitterTex.SampleLevel(sampler_EmitterTex, uvw, 0).r;

	const float rPosSqr = dot(rPosition, rPosition);
	const float injection = exp(-rPosSqr * _RecipDimensions.y);
	const float3 emitterForce = float3(0, _ForceMag, 0) * texStrength * injection;

	_VelocityTexRW[i] = _VelocityTex[i] + emitterForce;  
	_ReactionTexRW[i] = _ReactionTex[i] + float4(injection*_ForceMag * texStrength, 0..xxx);
}

[numthreads(8, 8, 8)]
void EmitWithTextureAndEffector(uint3 i : SV_DispatchThreadID)
{ 
	[branch]
	if( IsNotWithinDimensions( i ) ) return;

	// And lets assume always emit from the bottom.
	const float3 rPosition =  float3(0, i.y, 0);
	const float2 uvw = mad(i.xz, _RecipDimensions.xz, _HalfVoxel.xz);

	const float texStrength = _EmitterTex.SampleLevel(sampler_EmitterTex, uvw, 0).r;
	
	const float rPosSqr = dot(rPosition, rPosition);
	const float injection = exp(-rPosSqr * _RecipDimensions.y);

	float4 currentReactionCoord = _ReactionTex[i];
	currentReactionCoord.x = mad(_ForceMag * texStrength, injection, currentReactionCoord.x);

	float4 affectorReaction = 0..xxxx;

	const float3 affectorForce = ApplyEffector( i, currentReactionCoord.x, affectorReaction );
	const float3 emitterForce = float3(0, _ForceMag, 0) * texStrength * injection;
	const float3 resultantForce = emitterForce + affectorForce;

	_VelocityTexRW[i] = _VelocityTex[i] + resultantForce;  
	_ReactionTexRW[i] = currentReactionCoord + affectorReaction;
}

[numthreads(8, 8, 8)]
void Advect(uint3 i : SV_DispatchThreadID)
{ 
	[branch]
	if( IsNotWithinDimensions( i ) ) return;

	float3 uvw = i - (_VelocityTex[i].xyz * _Viscosity + _Gravity) * _TimeScale + _Translation;   

	uvw = mad(uvw, _RecipDimensions.xyz, _HalfVoxel.xyz);

	_VelocityTexRW[i] = _VelocityTex.SampleLevel(sampler_VelocityTex, uvw, 0);

	float4 r = _ReactionTex.SampleLevel(sampler_ReactionTex, uvw, 0);
	_ReactionTexRW[i] = max(r - _ReactionSpeed.xxxx * _TimeScale, 0..xxxx); 
}

[numthreads(8, 8, 8)]
void AdvectBackward(uint3 i : SV_DispatchThreadID)
{ 
	[branch]
	if( IsNotWithinDimensions( i ) ) return;

	float3 uvw = i + (_VelocityTex[i] * _Viscosity - _Gravity) * _TimeScale - _Translation;   

	uvw = mad(uvw, _RecipDimensions.xyz, _HalfVoxel.xyz);

	_VelocityTexRW[i] =  _VelocityTexA.SampleLevel(sampler_VelocityTexA, uvw, 0);
}

[numthreads(8, 8, 8)]
void AdvectMacCormack( uint3 i : SV_DispatchThreadID )
{ 
	[branch]
	if( IsNotWithinDimensions( i ) ) return;

	float3 uvw = i - (_VelocityTex[i] * _Viscosity + _Gravity) * _TimeScale + _Translation;   
	const uint3 traceBack = (uint3) uvw;
	uvw = mad(uvw, _RecipDimensions.xyz, _HalfVoxel.xyz);
	
	float3 s = _VelocityTex.SampleLevel(sampler_VelocityTex, uvw, 0);

	// Must revert to semi-langarian approach on boundries.
	[branch]
	if( !IsBoundry( i ) )
	{
		float3 lMin = INFINITY, lMax = -INFINITY;
	
		[unroll]
		for(uint index=0 ; index<8 ; index++)
		{
			float3 v = _VelocityTex[ traceBack + texCoordLimits[index] ];

			lMin = min(lMin, v);
			lMax = max(lMax, v);
		}

		s = clamp( mad( s - _VelocityTexA.SampleLevel(sampler_VelocityTexA, uvw, 0), 0.5.xxx, s ), lMin, lMax );
		
		float4 r = _ReactionTex.SampleLevel(sampler_ReactionTex, uvw, 0);
		_ReactionTexRW[i] = max(r - _ReactionSpeed.xxxx * _TimeScale, 0..xxxx); 
	}

	_VelocityTexRW[i] = s;
}

[numthreads(8, 8, 8)]
void Divergence(uint3 i : SV_DispatchThreadID)
{ 
	uint3 gridPos = uint3( i.x<<2, i.y, i.z );

	[branch]
	if( IsNotWithinDimensions( gridPos ) ) return;

	float4 left, right, down, up, back, forward;

	// NB : Utilise D3D out of bounds read = 0 for borders.
	right.x		= _VelocityTex[gridPos + uint3( 1,  0,  0)].x;
	left.x		= _VelocityTex[gridPos + uint3(-1,  0,  0)].x;
	up.x		= _VelocityTex[gridPos + uint3( 0,  1,  0)].y;
	down.x		= _VelocityTex[gridPos + uint3( 0, -1,  0)].y;
	forward.x	= _VelocityTex[gridPos + uint3( 0,  0,  1)].z;
	back.x		= _VelocityTex[gridPos + uint3( 0,  0, -1)].z;

	gridPos.x++;

	right.y		= _VelocityTex[gridPos + uint3( 1,  0,  0)].x;
	left.y		= _VelocityTex[gridPos + uint3(-1,  0,  0)].x;
	up.y		= _VelocityTex[gridPos + uint3( 0,  1,  0)].y;
	down.y		= _VelocityTex[gridPos + uint3( 0, -1,  0)].y;
	forward.y	= _VelocityTex[gridPos + uint3( 0,  0,  1)].z;
	back.y		= _VelocityTex[gridPos + uint3( 0,  0, -1)].z;

	gridPos.x++;

	right.z		= _VelocityTex[gridPos + uint3( 1,  0,  0)].x;
	left.z		= right.x;
	up.z		= _VelocityTex[gridPos + uint3( 0,  1,  0)].y;
	down.z		= _VelocityTex[gridPos + uint3( 0, -1,  0)].y;
	forward.z	= _VelocityTex[gridPos + uint3( 0,  0,  1)].z;
	back.z		= _VelocityTex[gridPos + uint3( 0,  0, -1)].z;

	gridPos.x++;

	right.w		= _VelocityTex[gridPos + uint3( 1,  0,  0)].x;
	left.w		= right.y;
	up.w		= _VelocityTex[gridPos + uint3( 0,  1,  0)].y;
	down.w		= _VelocityTex[gridPos + uint3( 0, -1,  0)].y;
	forward.w	= _VelocityTex[gridPos + uint3( 0,  0,  1)].z;
	back.w		= _VelocityTex[gridPos + uint3( 0,  0, -1)].z;

	_DivergenceTexRW[i] = (right - left + up - down + forward - back) * 0.5f;
}

void Jaccobi( uint3 index, const int ShouldClamp )
{
	float4 center	= _PressureTex[index];
	float4 up		= _PressureTex[UP_4];
	float4 down		= _PressureTex[DOWN_4];
	float4 right	= float4(center.yzw, _PressureTex[RIGHT_4].x);
	float4 left		= float4(_PressureTex[LEFT_4].w, center.xyz);
	float4 forward	= _PressureTex[FORWARD_4];
	float4 back		= _PressureTex[BACK_4];

	_PressureTexRW[ index ] =  (right + left + up + down + forward + back - _DivergenceTex[ index ]) * 0.166666666f;
}

[numthreads(8, 8, 8)]
void JaccobiClamped(uint3 i : SV_DispatchThreadID, uint3 g : SV_GroupThreadId)
{ 

	uint3 gridPos = uint3( i.x<<2, i.y, i.z );

  	[branch]
	if( IsNotWithinDimensions( gridPos ) ) return;

	Jaccobi( i, 1 );
}

[numthreads(8, 8, 8)]
void JaccobiUnclamped(uint3 i : SV_DispatchThreadID, uint3 g : SV_GroupThreadId)
{ 

	uint3 gridPos = uint3( i.x<<2, i.y, i.z );

  	[branch]
	if( IsNotWithinDimensions( gridPos ) ) return;

	Jaccobi( i, 0 );
}

void Project( uint3 index, uint3 gridPos, const int ShouldClamp  )
{
	float4 center	= _PressureTex[index];
	float4 up		= _PressureTex[UP_4];
	float4 down		= _PressureTex[DOWN_4];
	float4 right	= float4(center.yzw, _PressureTex[RIGHT_4].x);
	float4 left		= float4(_PressureTex[LEFT_4].w, center.xyz);
	float4 forward	= _PressureTex[FORWARD_4];
	float4 back		= _PressureTex[BACK_4];

	right	-= left;
	up		-= down;
	forward -= back;

	index = gridPos;

	const bool border =  gridPos.x <= 0 || gridPos.y <= 0 || gridPos.z <= 0 || gridPos.x >= _DimensionsMinusOne.x || gridPos.y >= _DimensionsMinusOne.y || gridPos.z >= _DimensionsMinusOne.z || gridPos.x+4 >= _DimensionsMinusOne.x;
	const float mod = (ApplyEffectorCollisions(index, kCollisionMask, kCollisionShift) || border ? -ShouldClamp : 1);

	[unroll]
	for(uint k=0 ; k<4 ; k++)
	{
		const float3 s = mad( float3(right[k], up[k], forward[k]), -0.5.xxx, _VelocityTex[index] );
		
		_VelocityTexRW[index] =  s * mod;
		_ReactionTexRW[index] = _ReactionTex[index] * mod; // copy

		++index.x;
	}
}

[numthreads(8, 8, 8)]
void ProjectClamped(uint3 i : SV_DispatchThreadID) 
{ 
	uint3 gridPos = uint3( i.x<<2, i.y, i.z );

	[branch]
	if( IsNotWithinDimensions( gridPos ) ) return;

	Project( i, gridPos, 1 );
}

[numthreads(8, 8, 8)]
void ProjectUnclamped(uint3 i : SV_DispatchThreadID) 
{ 
	uint3 gridPos = uint3( i.x<<2, i.y, i.z );

	[branch]
	if( IsNotWithinDimensions( gridPos ) ) return;

	Project( i, gridPos, 0 );
}

[numthreads(8, 8, 8)]
void Vorticity(uint3 i : SV_DispatchThreadID)
{
	[branch]
	if( IsNotWithinDimensions( i ) ) return;

	uint3 index = i;

    float3 right	= _VelocityTex[ min(_DimensionsMinusOne, index + uint3(0, 1, 0) ) ].xyz;
    float3 left		= _VelocityTex[ index - uint3(0, 1, 0) ].xyz;
    float3 up		= _VelocityTex[ min(_DimensionsMinusOne, index + uint3(1, 0, 0) ) ].xyz;
    float3 down		= _VelocityTex[ index - uint3(1, 0, 0) ].xyz;
    float3 forward	= _VelocityTex[ min(_DimensionsMinusOne, index + uint3(0, 0, 1) ) ].xyz;
    float3 back		= _VelocityTex[ index - uint3(0, 0, 1) ].xyz;

	right	-= left;
	up		-= down;
	forward -= back;

    float3 vorticity = float3((up.z - forward.y), (forward.x - right.z), (right.y - up.x) );

	_VorticityTexRW[i] = float4( vorticity, length(vorticity) );
    _VelocityTexRW[i] = _VelocityTex[i];
}

[numthreads(8, 8, 8)]
void Confinement(uint3 i : SV_DispatchThreadID)
{
	[branch]
	if( IsNotWithinDimensions( i ) ) return;

	uint3 index = i;

    float4 center	= _VorticityTex[i];
    float right		= _VorticityTex[ min(_DimensionsMinusOne, index + uint3(0, 1, 0) ) ].w;
    float left		= _VorticityTex[ index - uint3(0, 1, 0) ].w;
    float up		= _VorticityTex[ min(_DimensionsMinusOne, index + uint3(1, 0, 0) ) ].w;
    float down		= _VorticityTex[ index - uint3(1, 0, 0) ].w;
    float forward	= _VorticityTex[ min(_DimensionsMinusOne, index + uint3(0, 0, 1) ) ].w;
    float back		= _VorticityTex[ index - uint3(0, 0, 1) ].w;

    float3 force = normalize( float3( (right - left), (up - down), (forward - back) ) + 2.4414e-4 );
    float3 adjustmentForce = cross( force, center.xyz ) * _ConfinementScale * _RecipDimensions.xyz;

    _VelocityTexRW[i] = _VelocityTex[i] + adjustmentForce;
}

inline void SimulateAIO( uint3 index, uint3 gridPos, const int ShouldClamp  )
{
	// Divergence =============================================================
	float4 left, right, down, up, back, forward;
	// NB : Utilise D3D out of bounds read = 0 at borders.
	right.x		= _VelocityTex[gridPos + uint3( 1,  0,  0)].x;
	left.x		= _VelocityTex[gridPos + uint3(-1,  0,  0)].x;
	up.x		= _VelocityTex[gridPos + uint3( 0,  1,  0)].y;
	down.x		= _VelocityTex[gridPos + uint3( 0, -1,  0)].y;
	forward.x	= _VelocityTex[gridPos + uint3( 0,  0,  1)].z;
	back.x		= _VelocityTex[gridPos + uint3( 0,  0, -1)].z;

	gridPos.x++;

	right.y		= _VelocityTex[gridPos + uint3( 1,  0,  0)].x;
	left.y		= _VelocityTex[gridPos + uint3(-1,  0,  0)].x;
	up.y		= _VelocityTex[gridPos + uint3( 0,  1,  0)].y;
	down.y		= _VelocityTex[gridPos + uint3( 0, -1,  0)].y;
	forward.y	= _VelocityTex[gridPos + uint3( 0,  0,  1)].z;
	back.y		= _VelocityTex[gridPos + uint3( 0,  0, -1)].z;

	gridPos.x++;

	right.z		= _VelocityTex[gridPos + uint3( 1,  0,  0)].x;
	left.z		= _VelocityTex[gridPos + uint3(-1,  0,  0)].x;
	up.z		= _VelocityTex[gridPos + uint3( 0,  1,  0)].y;
	down.z		= _VelocityTex[gridPos + uint3( 0, -1,  0)].y;
	forward.z	= _VelocityTex[gridPos + uint3( 0,  0,  1)].z;
	back.z		= _VelocityTex[gridPos + uint3( 0,  0, -1)].z;

	gridPos.x++;

	right.w		= _VelocityTex[gridPos + uint3( 1,  0,  0)].x;
	left.w		= _VelocityTex[gridPos + uint3(-1,  0,  0)].x;
	up.w		= _VelocityTex[gridPos + uint3( 0,  1,  0)].y;
	down.w		= _VelocityTex[gridPos + uint3( 0, -1,  0)].y;
	forward.w	= _VelocityTex[gridPos + uint3( 0,  0,  1)].z;
	back.w		= _VelocityTex[gridPos + uint3( 0,  0, -1)].z;

	float4 calculatedDivergence = (right - left + up - down + forward - back) * 0.5f;

	// Jaccobi =======================================================
	float4 center	= _PressureTex[index];
	up				= _PressureTex[UP_4];
	down			= _PressureTex[DOWN_4];
	right			= float4(center.yzw, _PressureTex[RIGHT_4].x);
	left			= float4(_PressureTex[LEFT_4].w, center.xyz);
	forward			= _PressureTex[FORWARD_4];
	back			= _PressureTex[BACK_4];

	_PressureTexRW[ index ] =   ((right + left + up + down + forward + back) * _TimeScale - calculatedDivergence) * 0.166666666f;

	// Project =======================================================
	right	-= left;
	up		-= down;
	forward -= back;

	const bool border = !(all(gridPos) && all(gridPos - _DimensionsMinusOne) && (gridPos.x+4 < _DimensionsMinusOne.x));
	const float mod = (ApplyEffectorCollisions(gridPos, kCollisionMask, kCollisionShift) || border ? -ShouldClamp : 1);

	[unroll(4)]
	for(uint k=3 ; k>=0 ; --k)
	{
		float3 s = mad( float3(right[k], up[k], forward[k]), -0.5.xxx, _VelocityTex[gridPos] );

		_VelocityTexRW[gridPos] =  s * mod;
		_ReactionTexRW[gridPos] = _ReactionTex[gridPos] * mod; // copy

		gridPos.x--;
	}
}

[numthreads(8, 8, 8)]
void SimulateAIOClamped(uint3 i : SV_DispatchThreadID)
{ 
	uint3 gridPos = uint3( i.x<<2, i.y, i.z );

	[branch]
	if( IsNotWithinDimensions( gridPos ) ) return;
	
	SimulateAIO( i, gridPos, 1 );
}

[numthreads(8, 8, 8)]
void SimulateAIOUnclamped(uint3 i : SV_DispatchThreadID)
{ 
	uint3 gridPos = uint3( i.x<<2, i.y, i.z );

	[branch]
	if( IsNotWithinDimensions( gridPos ) ) return;
	
	SimulateAIO( i, gridPos, 0 );
}

[numthreads(8, 8, 8)]
void Clear(uint3 i : SV_DispatchThreadID)
{
	_VelocityTexRW[i]	= 0..xxx;
	_ReactionTexRW[i]	= 0..xxxx;
	_VorticityTexRW[i]	= 0..xxxx;
	_PressureTexRW[i]	= 0..xxxx;
	_DivergenceTexRW[i]	= 0..xxxx;
}